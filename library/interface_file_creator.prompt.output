Here's how you can achieve this by using the `ast` (Abstract Syntax Tree) module in Python:

```python
import ast

# Constants for the output string format
FILE_MSG = "{} contains the following elements:\n"
FUNC_MSG = "def {}({})\n"

def extract_function_interfaces(python_file_content, python_file_name):
    # Parse the python file content into an abstract syntax tree
    ast_tree = ast.parse(python_file_content)

    # Initialize the output string with the filename
    output_string = FILE_MSG.format(python_file_name)

    # Iterate over all top-level functions in the abstract syntax tree
    for node in ast.iter_child_nodes(ast_tree):
        if isinstance(node, ast.FunctionDef):
            # Extract the function name
            func_name = node.name

            # Extract the function parameters
            func_params = [arg.arg for arg in node.args.args]

            # Add the function interface to the output string
            output_string += FUNC_MSG.format(func_name, ', '.join(func_params))

    return output_string
```

This function `extract_function_interfaces` takes the contents of a Python file and its filename as inputs. It uses the `ast` module to parse the Python file content into an abstract syntax tree. It then iterates over all top-level functions in the tree, extracts their names and parameters, and adds their interfaces to the output string. The output string is formatted according to the provided example.

Please note that this function only extracts top-level functions, not functions nested within other functions or methods within classes. If you need to extract those as well, you would need to modify the function to recursively traverse the abstract syntax tree.

This function also assumes that the Python file content is a string. If you have the file path instead, you can read the file into a string using the `open` function.